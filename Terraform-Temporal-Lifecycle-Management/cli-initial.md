# Designing a Terraform + Temporal Lifecycle Management CLI

Modern infrastructure deployments often involve **multiple lifecycle stages** – from provisioning and configuration to updates and teardown. Managing these through raw Terraform alone can be challenging, as Terraform is focused on declarative infrastructure and lacks higher-level workflow orchestration[[1]](https://medium.com/%40surajsub_68985/workflow-orchestration-meets-infrastructure-as-code-5ce79a186ae2#:~:text=1,IO). By introducing **Temporal** (a workflow engine) as an orchestration layer, we can build a CLI tool that wraps Terraform to handle complex environment lifecycles with more reliability and flexibility[[2]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=When%20it%20comes%20to%20orchestrating,of%20reliability%2C%20scalability%2C%20and%20flexibility)[[3]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=Terraform%20alone%20cannot%20handle,scalable%20solution%20than%20using%20either). This solution envisions a generic CLI for **orchestrating one environment’s lifecycle** at a time, where users can define custom deployment policies and sequences, and enjoy features like drift detection, logging, and history tracking.

## Why Combine Terraform with Temporal?

Terraform excels at describing **what** infrastructure to create, but not **how** to coordinate multi-step processes or long-running tasks. For example, Terraform has limited error recovery and no built-in way to wait on external approvals or integrate non-IaC tasks[[1]](https://medium.com/%40surajsub_68985/workflow-orchestration-meets-infrastructure-as-code-5ce79a186ae2#:~:text=1,IO). Temporal, on the other hand, is a powerful open-source workflow engine that complements Terraform by providing **dynamic, fault-tolerant, long-running workflows** – with features like automatic retries, state persistence, concurrency control, and the ability to pause for external events[[3]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=Terraform%20alone%20cannot%20handle,scalable%20solution%20than%20using%20either)[[4]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=Temporal%20also%20handles%20retries%20and,multiple%20tools%20and%20processes%20seamlessly). Together, they let us orchestrate complex deployment flows that go beyond provisioning, making the process **more resilient and extensible** than using Terraform alone[[5]](https://medium.com/%40surajsub_68985/building-an-infrastructure-stack-using-temporal-terraform-on-aws-d2210b9f6582#:~:text=advantages%20in%20terms%20of%20scalability%2C,for%20building%20scalable%20and%20secure).

Notably, real-world use has validated this approach. For instance, companies like **Lyft** found that the standard Terraform automation (Atlantis) needed more scalable orchestration; they forked it to use Temporal as a backend for running Terraform jobs at scale[[6]](https://news.ycombinator.com/item?id=36658020#:~:text=Companies%20that%20use%20Atlantis%20at,house%20CI). This illustrates the need for a robust orchestrator to manage when and how Terraform operations run, with **Temporal ensuring reliability and scalability** of the process. HashiCorp itself leveraged Temporal to orchestrate internal infrastructure workflows (Nomad clusters) for better failure handling and self-service operations[[7]](https://temporal.io/resources/on-demand/temporal-hashicorp#:~:text=,save%20them%20time%20and%20effort)[[8]](https://temporal.io/resources/on-demand/temporal-hashicorp#:~:text=%2A%20Compute%20API%20for%20Self,and%20management%20of%20these%20workloads). In short, a Terraform+Temporal combo provides the best of both worlds: Terraform’s infrastructure-as-code power and Temporal’s workflow management for complex, **state-aware** automation[[9]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=Using%20Terraform%20and%20Temporal%20together,orchestrating%20complex%2C%20stateful%20workflows%20that)[[10]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=The%20Temporal,or%20send%20notifications%20to%20stakeholders).

## Design Goals and Key Features

The proposed abstraction is a **CLI tool** (command-line interface) acting as a wrapper around Terraform and Temporal. It targets a single environment per run (one environment’s lifecycle at a time) and is **cloud-agnostic** – no cloud-specific resource names appear in the CLI commands. Key design goals and features include:

* **Custom Lifecycle Policies:** Users (typically platform engineers) can define custom lifecycle workflows for their environment. This means you can specify the **sequence of steps** (plan, approvals, apply, post-deployment actions, etc.) and any policies (e.g. requiring security scans or manual approval before deploying to prod). The CLI will allow plugging in these custom workflows so that different teams or scenarios can have tailored deployment pipelines.
* **Ordered Deployment Sequences:** The abstraction supports orchestrating complex sequences of tasks in a defined order. For example, a workflow might *initialize network components, then deploy databases, then launch application resources*. Temporal ensures each step happens in the right order (or in parallel where appropriate) and handles dependencies between them. You can even mix in non-Terraform steps; for instance, **run Terraform**, then deploy application code, then run configuration scripts, all in one controlled workflow[[11]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=await%20run_terraform%28%22apply%22%29%20await%20run_kubectl%28%22apply%20,configure_ingress.yml)[[10]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=The%20Temporal,or%20send%20notifications%20to%20stakeholders).
* **Drift Detection and Handling:** **Drift** refers to when real infrastructure diverges from the last applied Terraform state. The CLI will offer drift detection by running Terraform plans with refreshed state to identify out-of-sync resources[[12]](https://www.hashicorp.com/en/blog/detecting-and-managing-drift-with-terraform#:~:text=Drift%20is%20the%20term%20for,commands%20run). It could expose commands like infra-cli drift to scan for drift and either report it or automatically reconcile it according to policy. For example, if drift is found, the tool might trigger a workflow to re-apply the desired state or create a ticket for manual review, depending on rules. This ensures that infrastructure stays aligned with the declared configuration, addressing a known challenge in IaC management[[13]](https://medium.com/%40DiggerHQ/the-case-for-headless-terraform-idp-5bc5a873805f#:~:text=uses%20spacelift%20to%20enable%20developer,solve%20their%20drift%20management%20issue).
* **Logging and Visibility:** All actions performed via the CLI are logged for visibility and debugging. Terraform’s output (plan diffs, apply logs) and any custom step outputs are captured. These logs can be streamed to the console for immediate feedback and also stored (e.g. in a central service or file) for later retrieval. Temporal naturally provides detailed workflow histories and internal logs, which the CLI can surface in a user-friendly way. For instance, a developer could run infra-cli logs --env <envName> --last-run to see the detailed log of the most recent deployment attempt. This helps **developers** understand failures and **SecOps/DevOps** to audit changes.
* **Historical Audit Trail:** The tool maintains a **history of environment changes**. Every lifecycle run (apply, update, destroy, etc.) is recorded with metadata like timestamp, user, and outcome. Users can query this via commands like infra-cli history --env <envName> to see past deployments. This is crucial for **SecOps and compliance**, providing an audit trail of what infrastructure changes were made and by whom. In large organizations, having audit logs and enforcement points (guardrails) around Terraform is a common requirement[[14]](https://medium.com/%40DiggerHQ/the-case-for-headless-terraform-idp-5bc5a873805f#:~:text=hosted%29,features%2Fbug%20fixes%20upstream%2C%20among%20others), so the abstraction will include this by design. Temporal workflows can be tagged or annotated for tracking, and important events (like an approval or a drift correction) can be logged as part of history.
* **Reliability and State Management:** Thanks to Temporal, the CLI’s underlying workflows are **resilient to failures**. If a deployment step fails or the process is interrupted, Temporal can retry or resume from where it left off once the issue is resolved[[15]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=The%20real%20value%20of%20workflow,already%20use%20work%20better%2C%20together)[[5]](https://medium.com/%40surajsub_68985/building-an-infrastructure-stack-using-temporal-terraform-on-aws-d2210b9f6582#:~:text=advantages%20in%20terms%20of%20scalability%2C,for%20building%20scalable%20and%20secure). This reliability is transparent to the end-user – from their perspective, the CLI command will ensure the environment eventually reaches the desired state or clearly report a failure after exhausting retries. The state of in-progress workflows is persisted (no manual checkpointing needed), which is a big improvement over ad-hoc scripts. This means operations like long-running database migrations, waiting for services to become healthy, or coordinating changes across services can be handled gracefully within the lifecycle workflow[[16]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=VM%20to%20pass%20health%20checks%2C,already%20use%20work%20better%2C%20together)[[4]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=Temporal%20also%20handles%20retries%20and,multiple%20tools%20and%20processes%20seamlessly).
* **Integration Hooks:** The abstraction allows **extensible hooks** before or after Terraform actions. For example, a pre-plan hook could run static analysis or policy checks on the Terraform code (ensuring security policies are met), and a post-apply hook could run smoke tests or update monitoring dashboards. Temporal’s orchestration makes it easy to call out to external systems or custom scripts during the workflow[[10]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=The%20Temporal,or%20send%20notifications%20to%20stakeholders). This is valuable for **SecOps** (who might want a security scan or approval step) and **Platform teams** (who might integrate CMDB updates, incident tracking, etc., automatically after provisioning). In fact, unlike plain Terraform, which stops at resource provisioning, a Temporal-orchestrated workflow can seamlessly hand off to other tools or processes as part of the deployment sequence[[10]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=The%20Temporal,or%20send%20notifications%20to%20stakeholders).

## CLI Structure and Usage

The CLI, say **infra-cli**, is designed with a user-friendly command structure that abstracts away direct Terraform commands. App developers and operators interact with high-level environment operations, while the CLI behind the scenes invokes the appropriate Temporal workflow which in turn calls Terraform. Below is an outline of how the CLI could look:

* **Initializing an Environment:** Perhaps via a command like infra-cli init --env <name> to set up a new environment configuration (this could set up state backends, etc.). This might not be always needed if environments are pre-defined, but providing an init helps bootstrap new ones.
* **Planning Changes:** Using infra-cli plan -e <envName> would trigger a Terraform plan for that environment’s configuration. The CLI would orchestrate a workflow to pull the latest config, run terraform plan, and return a summary of changes. The output might be saved for review. Example:

$ infra-cli plan --env prod
Computing plan for environment "prod"...
Plan Result: 3 to add, 1 to change, 0 to destroy. (Saved as plan\_1234)

This gives developers and platform engineers a safe preview of changes.

* **Applying Changes:** Using infra-cli apply -e <envName> will deploy changes. Under the hood, this might start a Temporal workflow that includes steps like: (1) optional pre-checks, (2) terraform apply (using the previously generated plan or generating one on the fly), and (3) post-deployment tasks. The CLI will stream important progress updates. For example:

$ infra-cli apply --env prod
Starting deployment workflow for "prod"...
Step 1/3: Security scan passed ✅
Step 2/3: Terraform apply in progress... ✅ (20 resources applied)
Step 3/3: Running post-deployment checks... ✅
Deployment succeeded! Environment "prod" is now up-to-date.

In case of errors, the CLI would report the failure and perhaps suggest running infra-cli logs for details. Thanks to Temporal, even if the CLI process disconnects, the workflow continues on the server, and the user can reconnect or fetch the status later.

* **Destroying an Environment:** Using infra-cli destroy -e <envName> triggers a teardown workflow. It ensures the sequence respects dependencies (perhaps removing application resources before network, etc.) and might require confirmation or approval if critical. Temporal would handle any interruptions or partial failures in teardown gracefully (e.g., retry deletes). The CLI might prompt for confirmation to avoid accidental deletions (with policies to enforce this for production).
* **Drift Detection & Reconciliation:** A command like infra-cli drift --env prod can initiate a drift-check workflow. This could run terraform plan in refresh-only mode and output if any drift is detected (resources that exist outside Terraform or have changes). If drift is found, the tool could optionally auto-apply fixes or at least mark the environment as "drifted". This might tie into notifications – e.g., alert SecOps if an unmanaged change was found. Because drift detection may be run on a schedule (say daily), the CLI could also serve to configure or trigger those Temporal **scheduled workflows**.
* **Viewing Logs:** As mentioned, infra-cli logs --env prod [--run <id>] would fetch the logs of the latest or a specific run. This includes Terraform output and any custom activity logs (Temporal can aggregate these). It helps developers troubleshoot failed deployments without digging into multiple systems.
* **History and Status:** Running infra-cli history -e prod might show a list of recent lifecycle runs for the environment, with timestamps and whether they succeeded or failed. For a quick check, infra-cli status -e prod could show the current state (e.g., "last applied 2 hours ago by Alice, no pending changes, no drift detected"). This gives **DevOps** teams quick insight into the state of an environment.

The CLI acts purely as a **front-end;** it triggers the appropriate workflows and displays results, hiding the complexity of Temporal and Terraform internals. For example, when an app developer issues an apply, they don’t need to know that behind the scenes a Temporal workflow is ensuring each step (init/plan/apply/post-tasks) executes reliably with all the safeguards. They simply see a unified process.

## Custom Lifecycle Policies and Workflow Definition

A powerful aspect of this abstraction is letting platform engineers define **custom lifecycle policies** and the ordering of steps. This could be done via a configuration file (e.g. a YAML or HCL file in the project) or through code by extending the CLI’s plugin system. The idea is to avoid hard-coding a single pipeline – instead, **teams can codify their desired workflow**. For example, a policy could define:

* **Pre-deployment checks:** List of actions to run before Terraform (security scans, cost estimation, linting, etc.). Any failure here would halt the deployment.
* **Deployment sequence:** Perhaps multiple Terraform modules or stacks that must be applied in order (network then database then application, etc.), or even integrating other tools (run a Kubernetes kubectl apply after Terraform, for instance). Temporal can orchestrate each as a sub-workflow, ensuring one completes before the next starts[[17]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=match%20at%20L724%20A,E%5BWorkflow%20Completed). The definition might allow marking some steps as parallelizable if they have no dependencies.
* **Post-deployment actions:** Steps after provisioning, such as running tests, populating a CMDB, sending notifications, or waiting for a manual verification. Temporal’s ability to wait for events is useful here – e.g., wait for a **human approval** or a validation signal before concluding the workflow[[4]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=Temporal%20also%20handles%20retries%20and,multiple%20tools%20and%20processes%20seamlessly).

These policies would also define **error-handling rules** (e.g., if a non-critical post-check fails, should it mark the deployment as failed or just warn and continue?) and **approval gates**. For instance, a SecOps policy might require that any production deployment pauses after the plan step and awaits a human approval (which could be given via the CLI or a web UI that signals the Temporal workflow) before proceeding to apply. Such human-in-the-loop approvals are easy to implement with Temporal’s signaling and waiting mechanisms[[4]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=Temporal%20also%20handles%20retries%20and,multiple%20tools%20and%20processes%20seamlessly).

In practice, a configuration for a lifecycle might look like this (pseudo-YAML for illustration):

lifecycle:
 name: "standard-env-deploy"
 steps:
 - id: "precheck"
 actions: ["tf\_validate", "opa\_policy\_check"]
 - id: "plan"
 actions: ["terraform\_plan"]
 requires: ["precheck"]
 - id: "approval"
 actions: ["manual\_approval"]
 requires: ["plan"]
 condition: env == "prod"
 - id: "apply"
 actions: ["terraform\_apply"]
 requires: ["plan", "approval"]
 - id: "post"
 actions: ["run\_smoke\_tests", "update\_cmdb", "notify\_slack"]
 requires: ["apply"]

The CLI would interpret such a config and orchestrate the steps via Temporal. In this example, for non-production environments it would skip the approval step (conditional), but in production it would pause until a human approves. The actual implementation of each action (tf\_validate, terraform\_plan, etc.) would be provided as activities (some likely built-in, some customizable) that the Temporal workflow can call. **Platform engineers** could extend these actions or integrate new ones (for example, add an action to trigger a vulnerability scan). This design ensures the abstraction is **generic and flexible** – it’s not tied to specific cloud services or resources, and new tools can be integrated without changing Terraform itself (Temporal can call any API or script as needed[[18]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=to%20develop%20and%20maintain,allow%20teams%20to%20leverage%20Terraform%27s)).

## Catering to Different Personas

One of the strengths of this approach is that it addresses the needs of various personas in the tech organization:

* **Application Developers:** For app devs, the CLI provides a straightforward interface to manage the lifecycle of the infrastructure their application needs. They don’t have to be Terraform experts – the heavy lifting is encapsulated. A developer can, for example, deploy an entire environment by running a single CLI command. They benefit from quick feedback (plans, logs) and confidence that if something goes wrong, it will be caught and possibly auto-ret retried. They can focus on coding and let the platform handle infra provisioning via standardized workflows.
* **Platform Engineers:** They are the ones who can define and evolve the lifecycle policies. This abstraction allows platform teams to encode best practices (ordering, dependencies, approved base modules, etc.) into the workflows. They might maintain the Terraform modules for various components and the Temporal workflow definitions that tie them together. If a new security step needs to be added across all deployments, platform engineers can add it to the workflow policy instead of relying on every developer to implement it. The CLI thus becomes an **Internal Developer Platform** interface – developers get self-service infrastructure, while platform engineers ensure consistency and compliance in how that infrastructure is produced[[19]](https://medium.com/%40DiggerHQ/the-case-for-headless-terraform-idp-5bc5a873805f#:~:text=At%20Lyft%20%E2%80%94%20they%20use,features%2Fbug%20fixes%20upstream%2C%20among%20others).
* **SecOps Teams:** Security and compliance teams can inject their requirements into the lifecycle. For example, they might require an **OPA policy check** on each Terraform plan or an approval step for certain sensitive changes. The history and logging features serve their need for audit trails. Every change is recorded, so investigating who changed a security group setting, for instance, is straightforward. Drift detection is also crucial for SecOps – if something was changed outside of Terraform (which could indicate shadow IT or a security incident), the system will catch it and flag it. SecOps can thus trust that the infrastructure remains in the expected state or is at least reporting anomalies[[12]](https://www.hashicorp.com/en/blog/detecting-and-managing-drift-with-terraform#:~:text=Drift%20is%20the%20term%20for,commands%20run). By using Temporal workflows, even compliance tasks like periodic access reviews or backups can be scheduled into the environment’s lifecycle (for example, a workflow that rotates keys every N days could be part of the policy).
* **DevOps / SRE Teams:** DevOps teams are often responsible for the tooling and ensuring reliable deployments. This Terraform+Temporal CLI simplifies their work by standardizing deployment processes. They no longer have to maintain flaky custom scripts or jerry-rig CI pipelines to handle Terraform’s quirks – the orchestration system handles locking, ordering, and retries. The CLI can be easily integrated into CI/CD as well (e.g., a CI job could call infra-cli plan and infra-cli apply as needed). Moreover, DevOps benefits from the observability Temporal provides: they can monitor running workflows, see where bottlenecks or failures occur, and get metrics on how long deployments take, etc. The CLI’s **history and status** commands give them quick insight into the state of environments. In essence, it reduces the toil in managing infrastructure by providing a higher-level control plane.

## Example Workflow in Action

To tie it all together, imagine a typical usage scenario:

1. **Developer Triggers a Deployment:** Alice, an application developer, has merged code that requires a new infrastructure component (say a database). She runs infra-cli apply --env staging to deploy the updated staging environment. The CLI confirms it has started a **Temporal workflow** for the staging environment deployment.
2. **Orchestration of Steps:** Temporal handles the defined lifecycle: first running a Terraform plan. The CLI outputs the plan summary to Alice. Suppose the policy requires approval for certain changes – since this is staging, no approval is needed and it proceeds automatically. Next, Terraform apply is executed. If everything goes well, it provisions the resources. Temporal then invokes a post-deployment script to run integration tests on the new infrastructure.
3. **Handling Failures:** During the apply, imagine a transient cloud API error occurs. Normally, this might cause Terraform to fail and require manual retry. But because it’s in a Temporal workflow, the apply step is automatically retried a few times (as per the retry policy)[[20]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=Temporal%20addresses%20challenges%20in%20automating,step). The issue resolves on a second attempt and the workflow continues. Alice might see a log message about a retry, but the CLI ultimately reports success.
4. **Completion and Logging:** The deployment finishes. Alice sees a success message with maybe a URL to application logs. The CLI internally has recorded this run in the history. All console output from Terraform and test results are stored. If something had failed hard, Alice could retrieve the logs and also know that no partial changes were left unreconciled (Temporal would have either retried or, if configured, rolled back changes).
5. **Drift Check (Automated):** Later, a DevOps engineer schedules a nightly drift check. At 2 AM, Temporal runs a drift detection workflow for all environments. It finds no drift in staging, but perhaps finds that in production an extra IAM policy was manually added outside Terraform. The system records this drift. The next morning, the SecOps team is alerted via an automated Slack message that production has drifted from code. They use the CLI to inspect details (infra-cli drift --env prod shows which resource is off) and decide to reconcile it. They run infra-cli apply --env prod which, due to drift, will plan to remove the unauthorized change, and they approve that plan to bring prod back in sync.
6. **Audit and Compliance:** A month later, an auditor or SecOps engineer might review the infra-cli history for production to ensure all changes had proper approvals. They see entries for each apply, including who initiated them and which were approved by whom (since the approval step logs the approver’s identity). This level of transparency is built-in, without developers having to manually document changes.

Through this scenario, we see the abstraction fulfilling its promise: **developers get simplicity**, and **engineers/SecOps get control and insight**. All of it is done in a *generic* way – the CLI commands don’t expose whether it’s AWS or Azure or any specific resource types under the hood. It’s effectively a **policy-driven environment lifecycle tool** powered by Terraform’s proven IaC capabilities and Temporal’s robust workflow engine.

## Conclusion

In summary, a CLI abstraction on top of Terraform and Temporal can greatly streamline the management of infrastructure lifecycles. It provides a single-tool experience for deploying, updating, and tearing down environments, while under the hood Temporal ensures the process is **reliable, observable, and extensible**. Users can define custom lifecycle sequences to fit their needs, whether it’s incorporating security checks, handling multi-step dependencies, or enforcing approvals. The inclusion of drift detection, comprehensive logs, and historical records addresses the needs for stability and compliance in modern DevOps practices. By leveraging Terraform for what it does best (infrastructure provisioning) and Temporal for higher-level orchestration, such a CLI empowers application developers, platform engineers, SecOps, and DevOps alike – enabling self-service infrastructure with safety and governance. It’s a **flexible, scalable solution** that abstracts complexity and lets each persona focus on their primary concerns, from coding and deployment to security and operations[[5]](https://medium.com/%40surajsub_68985/building-an-infrastructure-stack-using-temporal-terraform-on-aws-d2210b9f6582#:~:text=advantages%20in%20terms%20of%20scalability%2C,for%20building%20scalable%20and%20secure)[[19]](https://medium.com/%40DiggerHQ/the-case-for-headless-terraform-idp-5bc5a873805f#:~:text=At%20Lyft%20%E2%80%94%20they%20use,features%2Fbug%20fixes%20upstream%2C%20among%20others).

**Sources:**

* HashiCorp Terraform Blog – *Detecting and Managing Drift with Terraform*[[12]](https://www.hashicorp.com/en/blog/detecting-and-managing-drift-with-terraform#:~:text=Drift%20is%20the%20term%20for,commands%20run)
* Anton Krylov – *Terraform and Ansible is not enough* (Temporal orchestration benefits)[[9]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=Using%20Terraform%20and%20Temporal%20together,orchestrating%20complex%2C%20stateful%20workflows%20that)[[10]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=The%20Temporal,or%20send%20notifications%20to%20stakeholders)
* Suraj Subramanian – *Workflow Orchestration meets IaC* (Temporal+Terraform example)[[21]](https://medium.com/%40surajsub_68985/building-an-infrastructure-stack-using-temporal-terraform-on-aws-d2210b9f6582#:~:text=In%20conclusion%2C%20leveraging%20Temporal%E2%80%99s%20parent,for%20building%20scalable%20and%20secure)
* Digger HQ – *Headless Terraform IDP* (Terraform self-service and Temporal at Lyft)[[19]](https://medium.com/%40DiggerHQ/the-case-for-headless-terraform-idp-5bc5a873805f#:~:text=At%20Lyft%20%E2%80%94%20they%20use,features%2Fbug%20fixes%20upstream%2C%20among%20others)[[22]](https://medium.com/%40DiggerHQ/the-case-for-headless-terraform-idp-5bc5a873805f#:~:text=to%20add%20comment%20,similar%20to%20Github%20Actions%20yaml)
* Hacker News Discussion on Terraform Automation (Lyft’s Temporal-backed Atlantis)[[6]](https://news.ycombinator.com/item?id=36658020#:~:text=Companies%20that%20use%20Atlantis%20at,house%20CI)
* Temporal Documentation – HashiCorp case study (Temporal for infrastructure workflows)[[7]](https://temporal.io/resources/on-demand/temporal-hashicorp#:~:text=,save%20them%20time%20and%20effort)[[8]](https://temporal.io/resources/on-demand/temporal-hashicorp#:~:text=%2A%20Compute%20API%20for%20Self,and%20management%20of%20these%20workloads)

[[1]](https://medium.com/%40surajsub_68985/workflow-orchestration-meets-infrastructure-as-code-5ce79a186ae2#:~:text=1,IO) Workflow Orchestration meets Infrastructure as Code | by Suraj Subramanian | Medium

[https://medium.com/@surajsub\_68985/workflow-orchestration-meets-infrastructure-as-code-5ce79a186ae2](https://medium.com/%40surajsub_68985/workflow-orchestration-meets-infrastructure-as-code-5ce79a186ae2)

[[2]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=When%20it%20comes%20to%20orchestrating,of%20reliability%2C%20scalability%2C%20and%20flexibility) [[3]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=Terraform%20alone%20cannot%20handle,scalable%20solution%20than%20using%20either) [[4]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=Temporal%20also%20handles%20retries%20and,multiple%20tools%20and%20processes%20seamlessly) [[9]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=Using%20Terraform%20and%20Temporal%20together,orchestrating%20complex%2C%20stateful%20workflows%20that) [[10]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=The%20Temporal,or%20send%20notifications%20to%20stakeholders) [[11]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=await%20run_terraform%28%22apply%22%29%20await%20run_kubectl%28%22apply%20,configure_ingress.yml) [[15]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=The%20real%20value%20of%20workflow,already%20use%20work%20better%2C%20together) [[16]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=VM%20to%20pass%20health%20checks%2C,already%20use%20work%20better%2C%20together) [[17]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=match%20at%20L724%20A,E%5BWorkflow%20Completed) [[18]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=to%20develop%20and%20maintain,allow%20teams%20to%20leverage%20Terraform%27s) [[20]](https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6#:~:text=Temporal%20addresses%20challenges%20in%20automating,step) Terraform and Ansible is not enough - DEV Community

<https://dev.to/avkr/terraform-and-ansible-is-not-enough-4nf6>

[[5]](https://medium.com/%40surajsub_68985/building-an-infrastructure-stack-using-temporal-terraform-on-aws-d2210b9f6582#:~:text=advantages%20in%20terms%20of%20scalability%2C,for%20building%20scalable%20and%20secure) [[21]](https://medium.com/%40surajsub_68985/building-an-infrastructure-stack-using-temporal-terraform-on-aws-d2210b9f6582#:~:text=In%20conclusion%2C%20leveraging%20Temporal%E2%80%99s%20parent,for%20building%20scalable%20and%20secure) Building an Infrastructure Stack using Temporal+Terraform on AWS | by Suraj Subramanian | Medium

[https://medium.com/@surajsub\_68985/building-an-infrastructure-stack-using-temporal-terraform-on-aws-d2210b9f6582](https://medium.com/%40surajsub_68985/building-an-infrastructure-stack-using-temporal-terraform-on-aws-d2210b9f6582)

[[6]](https://news.ycombinator.com/item?id=36658020#:~:text=Companies%20that%20use%20Atlantis%20at,house%20CI) I'm surprised nobody has mentioned Atlantis yet. Running bare terraform in CI is... | Hacker News

<https://news.ycombinator.com/item?id=36658020>

[[7]](https://temporal.io/resources/on-demand/temporal-hashicorp#:~:text=,save%20them%20time%20and%20effort) [[8]](https://temporal.io/resources/on-demand/temporal-hashicorp#:~:text=%2A%20Compute%20API%20for%20Self,and%20management%20of%20these%20workloads) Using Temporal at Hashicorp | Temporal

<https://temporal.io/resources/on-demand/temporal-hashicorp>

[[12]](https://www.hashicorp.com/en/blog/detecting-and-managing-drift-with-terraform#:~:text=Drift%20is%20the%20term%20for,commands%20run) Detecting and Managing Drift with Terraform

<https://www.hashicorp.com/en/blog/detecting-and-managing-drift-with-terraform>

[[13]](https://medium.com/%40DiggerHQ/the-case-for-headless-terraform-idp-5bc5a873805f#:~:text=uses%20spacelift%20to%20enable%20developer,solve%20their%20drift%20management%20issue) [[14]](https://medium.com/%40DiggerHQ/the-case-for-headless-terraform-idp-5bc5a873805f#:~:text=hosted%29,features%2Fbug%20fixes%20upstream%2C%20among%20others) [[19]](https://medium.com/%40DiggerHQ/the-case-for-headless-terraform-idp-5bc5a873805f#:~:text=At%20Lyft%20%E2%80%94%20they%20use,features%2Fbug%20fixes%20upstream%2C%20among%20others) [[22]](https://medium.com/%40DiggerHQ/the-case-for-headless-terraform-idp-5bc5a873805f#:~:text=to%20add%20comment%20,similar%20to%20Github%20Actions%20yaml) The Case for ‘Headless Terraform IDP’ | by Digger HQ | Medium

[https://medium.com/@DiggerHQ/the-case-for-headless-terraform-idp-5bc5a873805f](https://medium.com/%40DiggerHQ/the-case-for-headless-terraform-idp-5bc5a873805f)
